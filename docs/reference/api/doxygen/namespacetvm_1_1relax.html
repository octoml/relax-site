<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tvm: tvm::relax Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relax.html">relax</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relax Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1attr.html">attr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relax_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AdaptivePool2DAttrs.html">AdaptivePool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 2d adaptive pool operator.  <a href="structtvm_1_1relax_1_1AdaptivePool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AllocTensorAttrs.html">AllocTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for allocating tensor.  <a href="structtvm_1_1relax_1_1AllocTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AndPattern.html">AndPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1AndPatternNode.html" title="Match a conjunction of other patterns. ">AndPatternNode</a>.  <a href="classtvm_1_1relax_1_1AndPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AndPatternNode.html">AndPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a conjunction of other patterns.  <a href="classtvm_1_1relax_1_1AndPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AssertOpAttrs.html">AssertOpAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1AstypeAttrs.html">AstypeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in astype operator.  <a href="structtvm_1_1relax_1_1AstypeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AttrPattern.html">AttrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1AttrPatternNode.html" title="A pattern that asserting a root pattern has certain attributes. ">AttrPatternNode</a>.  <a href="classtvm_1_1relax_1_1AttrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1AttrPatternNode.html">AttrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has certain attributes.  <a href="classtvm_1_1relax_1_1AttrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1BatchNormAttrs.html">BatchNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in batch_norm operator.  <a href="structtvm_1_1relax_1_1BatchNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingBlock.html">BindingBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingBlockNode.html">BindingBlockNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BindingNode.html">BindingNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of a variable binding in Relax.  <a href="classtvm_1_1relax_1_1BindingNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1BlockBuilderNode.html">BlockBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to build Relax binding blocks.  <a href="classtvm_1_1relax_1_1BlockBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1BuiltinFuncAttrs.html">BuiltinFuncAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common attribute for built-in runtime packed functions.  <a href="structtvm_1_1relax_1_1BuiltinFuncAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> corresponds to callable invocation. Corresponds to operation in computational graph terminology.  <a href="classtvm_1_1relax_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1CallPatternNode.html">CallPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match a callable node in Relax.  <a href="classtvm_1_1relax_1_1CallPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Choice.html">Choice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ChoiceNode.html" title="Choice manages a set of keys for transformation and constraint functions. ">ChoiceNode</a>.  <a href="classtvm_1_1relax_1_1Choice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ChoiceNode.html">ChoiceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Choice.html" title="Managed reference to ChoiceNode. ">Choice</a> manages a set of keys for transformation and constraint functions.  <a href="classtvm_1_1relax_1_1ChoiceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ConcatAttrs.html">ConcatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in concat operators.  <a href="structtvm_1_1relax_1_1ConcatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantNode.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a> tensor.  <a href="classtvm_1_1relax_1_1ConstantNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern. ">ConstantPattern</a>.  <a href="classtvm_1_1relax_1_1ConstantPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ConstantPatternNode.html">ConstantPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax <a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a>.  <a href="classtvm_1_1relax_1_1ConstantPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Conv2DAttrs.html">Conv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in Conv2d operator.  <a href="structtvm_1_1relax_1_1Conv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Database.html">Database</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DatabaseNode.html">DatabaseNode</a>.  <a href="classtvm_1_1relax_1_1Database.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DatabaseNode.html">DatabaseNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockNode.html">DataflowBlockNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockRewrite.html">DataflowBlockRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement rewriter for <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">relax.DataflowBlock</a>.  <a href="classtvm_1_1relax_1_1DataflowBlockRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowBlockRewriteNode.html">DataflowBlockRewriteNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement rewriter for <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">relax.DataflowBlock</a>.  <a href="classtvm_1_1relax_1_1DataflowBlockRewriteNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVar.html">DataflowVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarNode.html">DataflowVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sub-type of the variable node used to mark dataflow variables from normal visible "function local" bindings.  <a href="classtvm_1_1relax_1_1DataflowVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarPattern.html">DataflowVarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1DataflowVarPattern.html" title="Managed reference to a DataflowVarPattern. ">DataflowVarPattern</a>.  <a href="classtvm_1_1relax_1_1DataflowVarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataflowVarPatternNode.html">DataflowVarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Dataflow Variable.  <a href="classtvm_1_1relax_1_1DataflowVarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypeImm.html">DataTypeImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DataTypeImm.html" title="Managed reference to DataTypeImm. ">DataTypeImm</a>.  <a href="classtvm_1_1relax_1_1DataTypeImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypeImmNode.html">DataTypeImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a data type constant.  <a href="classtvm_1_1relax_1_1DataTypeImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypePattern.html">DataTypePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DataTypePatternNode.html" title="A pattern that asserting a root pattern has a certain data type. ">DataTypePatternNode</a>.  <a href="classtvm_1_1relax_1_1DataTypePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DataTypePatternNode.html">DataTypePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has a certain data type.  <a href="classtvm_1_1relax_1_1DataTypePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to dataflow patterns.  <a href="classtvm_1_1relax_1_1DFPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor.html">DFPatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> argument.  <a href="classtvm_1_1relax_1_1DFPatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor_3_01R_07const_01DFPattern_01_6n_00_01Args_8_8_8_08_4.html">DFPatternFunctor&lt; R(const DFPattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternNode.html">DFPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all dataflow patterns.  <a href="classtvm_1_1relax_1_1DFPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DFPatternVisitor.html">DFPatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relax_1_1DFPatternFunctor.html" title="A dynamical functor that dispatches on in the first DFPattern argument. ">DFPatternFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relax_1_1DFPatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1DropoutAttrs.html">DropoutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dropout operator.  <a href="structtvm_1_1relax_1_1DropoutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DynTensorType.html">DynTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1DynTensorTypeNode.html">DynTensorTypeNode</a>.  <a href="classtvm_1_1relax_1_1DynTensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1DynTensorTypeNode.html">DynTensorTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExecBuilder.html">ExecBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExecBuilderNode.html">ExecBuilderNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder provides api to build VM executable with instructions.  <a href="classtvm_1_1relax_1_1ExecBuilderNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ExpandDimsAttrs.html">ExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in expand_dims operators.  <a href="structtvm_1_1relax_1_1ExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>.  <a href="classtvm_1_1relax_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator works in normal form.  <a href="classtvm_1_1relax_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprMutatorBase.html">ExprMutatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator works in unnormalized form.  <a href="classtvm_1_1relax_1_1ExprMutatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to an <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern. ">ExprPattern</a>.  <a href="classtvm_1_1relax_1_1ExprPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprPatternNode.html">ExprPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for Relax Expression.  <a href="classtvm_1_1relax_1_1ExprPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relax_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relax_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFunc.html">ExternFunc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncNode.html">ExternFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extern function, which can represent packed function.  <a href="classtvm_1_1relax_1_1ExternFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncPattern.html">ExternFuncPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ExternFuncPatternNode.html" title="A pattern of external function. ">ExternFuncPatternNode</a>.  <a href="classtvm_1_1relax_1_1ExternFuncPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ExternFuncPatternNode.html">ExternFuncPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern of external function.  <a href="classtvm_1_1relax_1_1ExternFuncPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1FuncStructInfoNode.html" title="Structure information about function. ">FuncStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1FuncStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FuncStructInfoNode.html">FuncStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure information about function.  <a href="classtvm_1_1relax_1_1FuncStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionNode.html">FunctionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Relax function.  <a href="classtvm_1_1relax_1_1FunctionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionPattern.html">FunctionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1FunctionPatternNode.html" title="A pattern to match a Relax Function. ">FunctionPatternNode</a>.  <a href="classtvm_1_1relax_1_1FunctionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1FunctionPatternNode.html">FunctionPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match a Relax <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>.  <a href="classtvm_1_1relax_1_1FunctionPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1GlobalVarPattern.html">GlobalVarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1GlobalVarPattern.html" title="Managed reference to a GlobalVarPattern. ">GlobalVarPattern</a>.  <a href="classtvm_1_1relax_1_1GlobalVarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1GlobalVarPatternNode.html">GlobalVarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Global Variable.  <a href="classtvm_1_1relax_1_1GlobalVarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1IfNode.html">IfNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition expression.  <a href="classtvm_1_1relax_1_1IfNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1InitAttrs.html">InitAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in full/full_like, ones/ones_like, and zeros/zeros_like operators.  <a href="structtvm_1_1relax_1_1InitAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1IRFunctor.html">IRFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1IRFunctor_3_01R_07const_01ObjectRef_01_6n_00_01Args_8_8_8_08_4.html">IRFunctor&lt; R(const ObjectRef &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Knob.html">Knob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1KnobNode.html" title="Knob manages a set of valid choices for an optimization. ">KnobNode</a>.  <a href="classtvm_1_1relax_1_1Knob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1KnobNode.html">KnobNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Knob.html" title="Managed reference to KnobNode. ">Knob</a> manages a set of valid choices for an optimization.  <a href="classtvm_1_1relax_1_1KnobNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1LayerNormAttrs.html">LayerNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in layer_norm operator.  <a href="structtvm_1_1relax_1_1LayerNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1LeafExpr.html">LeafExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1BaseExprNode.html" title="Base type of all the expressions. ">BaseExprNode</a>.  <a href="classtvm_1_1relax_1_1LeafExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1LeafExprNode.html">LeafExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all (non-function) leaf Exprs.  <a href="classtvm_1_1relax_1_1LeafExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchCast.html">MatchCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1MatchCastNode.html" title="Runtime-match the value to the struct info. ">MatchCastNode</a>.  <a href="classtvm_1_1relax_1_1MatchCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1MatchCastNode.html">MatchCastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime-match the value to the struct info.  <a href="classtvm_1_1relax_1_1MatchCastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MatmulAttrs.html">MatmulAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for matmul operator.  <a href="structtvm_1_1relax_1_1MatmulAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MaxPool2DAttrs.html">MaxPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in max_pool2d operator.  <a href="structtvm_1_1relax_1_1MaxPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MemAllocStorageAttrs.html">MemAllocStorageAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for allocating storage in memory planning.  <a href="structtvm_1_1relax_1_1MemAllocStorageAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1MemAllocTensorAttrs.html">MemAllocTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for allocating tensor in memory planning.  <a href="structtvm_1_1relax_1_1MemAllocTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NameTable.html">NameTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility data structure for generating unique names for IR construction.  <a href="classtvm_1_1relax_1_1NameTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container that stores possibly nested message with leaf message type T.  <a href="classtvm_1_1relax_1_1NestedMsg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NotPattern.html">NotPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1NotPatternNode.html" title="Pattern for rejecting a certain pattern. ">NotPatternNode</a>.  <a href="classtvm_1_1relax_1_1NotPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1NotPatternNode.html">NotPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for rejecting a certain pattern.  <a href="classtvm_1_1relax_1_1NotPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectStructInfo.html">ObjectStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ObjectStructInfoNode.html" title="Opaque object. ">ObjectStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1ObjectStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectStructInfoNode.html">ObjectStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque object.  <a href="classtvm_1_1relax_1_1ObjectStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectType.html">ObjectType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ObjectTypeNode.html">ObjectTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1OrPattern.html">OrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1OrPatternNode.html" title="Match a disjunction of other patterns. ">OrPatternNode</a>.  <a href="classtvm_1_1relax_1_1OrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1OrPatternNode.html">OrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a disjunction of other patterns.  <a href="classtvm_1_1relax_1_1OrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PackedFuncType.html">PackedFuncType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PackedFuncTypeNode.html">PackedFuncTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PairCons.html">PairCons</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint of a <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> edge (producer -&gt; consumer) in graph-level matching.  <a href="structtvm_1_1relax_1_1PairCons.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a pattern context.  <a href="classtvm_1_1relax_1_1PatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternContextNode.html">PatternContextNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context to manage the graph-level pattern matching.  <a href="classtvm_1_1relax_1_1PatternContextNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to pattern sequences.  <a href="classtvm_1_1relax_1_1PatternSeq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PatternSeqNode.html">PatternSeqNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of DFPatterns that the previous <a class="el" href="classtvm_1_1relax_1_1DFPattern.html" title="Managed reference to dataflow patterns. ">DFPattern</a> is connected to the next one.  <a href="classtvm_1_1relax_1_1PatternSeqNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PermuteDimsAttrs.html">PermuteDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in permute_dims operator.  <a href="structtvm_1_1relax_1_1PermuteDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimArrPattern.html">PrimArrPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1PrimArrPattern.html" title="Managed reference to a PrimArrPattern. ">PrimArrPattern</a>.  <a href="classtvm_1_1relax_1_1PrimArrPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimArrPatternNode.html">PrimArrPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match an array of <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>.  <a href="classtvm_1_1relax_1_1PrimArrPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimStructInfo.html">PrimStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PrimStructInfoNode.html" title="Primitive value. ">PrimStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1PrimStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimStructInfoNode.html">PrimStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive value.  <a href="classtvm_1_1relax_1_1PrimStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimValue.html">PrimValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PrimValueNode.html" title="PrimValue. ">PrimValueNode</a>.  <a href="classtvm_1_1relax_1_1PrimValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PrimValueNode.html">PrimValueNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1PrimValue.html" title="Managed reference to PrimValueNode. ">PrimValue</a>.  <a href="classtvm_1_1relax_1_1PrimValueNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1PrintAttrs.html">PrintAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PyExprMutator.html">PyExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PyExprMutatorNode.html" title="The abstract interface of ExprMutator. ">PyExprMutatorNode</a>.  <a href="classtvm_1_1relax_1_1PyExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PyExprMutatorNode.html">PyExprMutatorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface of <a class="el" href="classtvm_1_1relax_1_1ExprMutator.html" title="A mutator works in normal form. ">ExprMutator</a>.  <a href="classtvm_1_1relax_1_1PyExprMutatorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PyExprVisitor.html">PyExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1PyExprVisitorNode.html" title="The abstract interface of ExprVisitor. ">PyExprVisitorNode</a>.  <a href="classtvm_1_1relax_1_1PyExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1PyExprVisitorNode.html">PyExprVisitorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract interface of <a class="el" href="classtvm_1_1relax_1_1ExprVisitor.html" title="A simple visitor wrapper around ExprFunctor. Recursively visit the content. ">ExprVisitor</a>.  <a href="classtvm_1_1relax_1_1PyExprVisitorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1Resize2DAttrs.html">Resize2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize2d operator.  <a href="structtvm_1_1relax_1_1Resize2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SeqExpr.html">SeqExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1SeqExprNode.html">SeqExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of blocks followed by an expression.  <a href="classtvm_1_1relax_1_1SeqExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeExpr.html">ShapeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeExprNode.html">ShapeExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shape expression which allows users to construct a shape containing <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a>.  <a href="classtvm_1_1relax_1_1ShapeExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1ShapeHeapAttrs.html">ShapeHeapAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for decoding/making shape to/from VM heap.  <a href="structtvm_1_1relax_1_1ShapeHeapAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapePattern.html">ShapePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ShapePatternNode.html" title="A pattern that asserting a root pattern has a certain shape. ">ShapePatternNode</a>.  <a href="classtvm_1_1relax_1_1ShapePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapePatternNode.html">ShapePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that asserting a root pattern has a certain shape.  <a href="classtvm_1_1relax_1_1ShapePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeStructInfo.html">ShapeStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1ShapeStructInfoNode.html" title="StructInfo of shape value. ">ShapeStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1ShapeStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeStructInfoNode.html">ShapeStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> of shape value.  <a href="classtvm_1_1relax_1_1ShapeStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeType.html">ShapeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1ShapeTypeNode.html">ShapeTypeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SoftmaxAttrs.html">SoftmaxAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relax_1_1SoftmaxAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SplitAttrs.html">SplitAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in split operator.  <a href="structtvm_1_1relax_1_1SplitAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1SqueezeAttrs.html">SqueezeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in squeeze operators.  <a href="structtvm_1_1relax_1_1SqueezeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1StatisticalAttrs.html">StatisticalAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for statistical operators.  <a href="structtvm_1_1relax_1_1StatisticalAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1StridedSliceAttrs.html">StridedSliceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in strided_slice operator.  <a href="structtvm_1_1relax_1_1StridedSliceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StringImm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1StringImm.html" title="Managed reference to StringImm. ">StringImm</a>.  <a href="classtvm_1_1relax_1_1StringImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent a string literal constant.  <a href="classtvm_1_1relax_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1StructInfoNode.html" title="Base type of all structure information. ">StructInfoNode</a>.  <a href="classtvm_1_1relax_1_1StructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoFunctor.html">StructInfoFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoFunctor_3_01R_07const_01StructInfo_01_6n_00_01Args_8_8_8_08_4.html">StructInfoFunctor&lt; R(const StructInfo &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoMutator.html">StructInfoMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfoMutator.html" title="StructInfoMutator that mutates struct info. ">StructInfoMutator</a> that mutates struct info.  <a href="classtvm_1_1relax_1_1StructInfoMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoNode.html">StructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type of all structure information.  <a href="classtvm_1_1relax_1_1StructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1StructInfoVisitor.html">StructInfoVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct info visitor.  <a href="classtvm_1_1relax_1_1StructInfoVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TakeAttrs.html">TakeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in take operator.  <a href="structtvm_1_1relax_1_1TakeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorStructInfo.html">TensorStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TensorStructInfoNode.html" title="StructInfo of Tensor. ">TensorStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1TensorStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TensorStructInfoNode.html">TensorStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> of Tensor.  <a href="classtvm_1_1relax_1_1TensorStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Trace.html">Trace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TraceNode.html" title="Trace manages history of optimization decisions. ">TraceNode</a>.  <a href="classtvm_1_1relax_1_1Trace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TraceNode.html">TraceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Trace.html" title="Managed reference to TraceNode. ">Trace</a> manages history of optimization decisions.  <a href="classtvm_1_1relax_1_1TraceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1TriluAttrs.html">TriluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tril and triu operator.  <a href="structtvm_1_1relax_1_1TriluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuningRecord.html">TuningRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The managed reference of <a class="el" href="classtvm_1_1relax_1_1TuningRecordNode.html" title="The class of tuning records. ">TuningRecordNode</a>.  <a href="classtvm_1_1relax_1_1TuningRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuningRecordNode.html">TuningRecordNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class of tuning records.  <a href="classtvm_1_1relax_1_1TuningRecordNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemNode.html">TupleGetItemNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index-th field out of a tuple.  <a href="classtvm_1_1relax_1_1TupleGetItemNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html" title="A pattern to match n&#39;th indexing to a tuple. ">TupleGetItemPatternNode</a>.  <a href="classtvm_1_1relax_1_1TupleGetItemPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html">TupleGetItemPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match n'th indexing to a tuple.  <a href="classtvm_1_1relax_1_1TupleGetItemPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleNode.html">TupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relax_1_1TupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TuplePatternNode.html" title="Pattern to match a tuple of ordered expressions. ">TuplePatternNode</a>.  <a href="classtvm_1_1relax_1_1TuplePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TuplePatternNode.html">TuplePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern to match a tuple of ordered expressions.  <a href="classtvm_1_1relax_1_1TuplePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleStructInfo.html">TupleStructInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TupleStructInfoNode.html" title="StructInfo of Tuple. ">TupleStructInfoNode</a>.  <a href="classtvm_1_1relax_1_1TupleStructInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TupleStructInfoNode.html">TupleStructInfoNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> of <a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>.  <a href="classtvm_1_1relax_1_1TupleStructInfoNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TypePattern.html">TypePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1TypePatternNode.html" title="Pattern for matching a certain type. ">TypePatternNode</a>.  <a href="classtvm_1_1relax_1_1TypePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1TypePatternNode.html">TypePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pattern for matching a certain type.  <a href="classtvm_1_1relax_1_1TypePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1UniqueAttrs.html">UniqueAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in unique operator.  <a href="structtvm_1_1relax_1_1UniqueAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html">UnorderedTuplePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html" title="A pattern to match multiple expressions unorderedly. ">UnorderedTuplePatternNode</a>.  <a href="classtvm_1_1relax_1_1UnorderedTuplePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html">UnorderedTuplePatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to match multiple expressions unorderedly.  <a href="classtvm_1_1relax_1_1UnorderedTuplePatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarBinding.html">VarBinding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarBindingNode.html">VarBindingNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable class for all Relax bindings.  <a href="classtvm_1_1relax_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern. ">VarPattern</a>.  <a href="classtvm_1_1relax_1_1VarPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1VarPatternNode.html">VarPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pattern to Match a Relax Variable.  <a href="classtvm_1_1relax_1_1VarPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1VMAllocStorageAttrs.html">VMAllocStorageAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for allocating storage on Relax VM.  <a href="structtvm_1_1relax_1_1VMAllocStorageAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1VMAllocTensorAttrs.html">VMAllocTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for allocating tensor on Relax VM.  <a href="structtvm_1_1relax_1_1VMAllocTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relax_1_1WildcardPatternNode.html" title="Wildcard Pattern is a pattern that can match anything. ">WildcardPatternNode</a>.  <a href="classtvm_1_1relax_1_1WildcardPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relax_1_1WildcardPatternNode.html">WildcardPatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wildcard Pattern is a pattern that can match anything.  <a href="classtvm_1_1relax_1_1WildcardPatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relax_1_1WorkloadEqual.html">WorkloadEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The equality check for Workload.  <a href="structtvm_1_1relax_1_1WorkloadEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8f6ef3d9aaba0138f730a520d7ebbfb3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> = <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a></td></tr>
<tr class="separator:a8f6ef3d9aaba0138f730a520d7ebbfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89e5aa7e722c41dafa36ca83d9d8091"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae89e5aa7e722c41dafa36ca83d9d8091">ExprNode</a> = <a class="el" href="classtvm_1_1RelayExprNode.html">RelayExprNode</a></td></tr>
<tr class="separator:ae89e5aa7e722c41dafa36ca83d9d8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2fd4ee22f1a9f4ebd6360992f89e15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1a2fd4ee22f1a9f4ebd6360992f89e15">FInferStructInfo</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:a1a2fd4ee22f1a9f4ebd6360992f89e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer output struct info given the call.  <a href="#a1a2fd4ee22f1a9f4ebd6360992f89e15">More...</a><br /></td></tr>
<tr class="separator:a1a2fd4ee22f1a9f4ebd6360992f89e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f471eb3ea093c316f3a4e9262a418"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad48f471eb3ea093c316f3a4e9262a418">FCallPacked</a> = <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:ad48f471eb3ea093c316f3a4e9262a418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed function implementation for operators. The relax operator will be lowered to this packed function call during codegen.  <a href="#ad48f471eb3ea093c316f3a4e9262a418">More...</a><br /></td></tr>
<tr class="separator:ad48f471eb3ea093c316f3a4e9262a418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30be57dbb36533467727929c21bd237"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af30be57dbb36533467727929c21bd237">StructInfoDeriveFunc</a> = <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx)&gt;</td></tr>
<tr class="memdesc:af30be57dbb36533467727929c21bd237"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom-defined <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> derivation function.  <a href="#af30be57dbb36533467727929c21bd237">More...</a><br /></td></tr>
<tr class="separator:af30be57dbb36533467727929c21bd237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a04ee98afc287f8466486f83957bbceb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a> { <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2aea0d6c7bc4e0f3e1ae27af5ab8d3ead1">BaseCheckResult::kFailL0</a> = 0, 
<a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a44bf4c796712d49aa9e166a28b5b4877">BaseCheckResult::kFailL1</a> = 1, 
<a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a445a5e4200190564cfb0a1a85823831f">BaseCheckResult::kFailL2</a> = 2, 
<a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2a42b60afb2c7698ee5c4d41840ca1210e">BaseCheckResult::kPass</a> = 3
 }<tr class="memdesc:a04ee98afc287f8466486f83957bbceb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fine grained result of base check.  <a href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a04ee98afc287f8466486f83957bbceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92be13bb7d6ad7edd1e82c93b9cae11b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a92be13bb7d6ad7edd1e82c93b9cae11b">CanProveShapeEqual</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;lhs, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana)</td></tr>
<tr class="memdesc:a92be13bb7d6ad7edd1e82c93b9cae11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can prove the two symbolic shape arrays equals to each other.  <a href="#a92be13bb7d6ad7edd1e82c93b9cae11b">More...</a><br /></td></tr>
<tr class="separator:a92be13bb7d6ad7edd1e82c93b9cae11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0d355ea6891b47940c7bf24a55d8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aafb0d355ea6891b47940c7bf24a55d8b">CanProveShapeEqual</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;lhs, const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana)</td></tr>
<tr class="memdesc:aafb0d355ea6891b47940c7bf24a55d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can prove the two symbolic shape expressions equals to each other.  <a href="#aafb0d355ea6891b47940c7bf24a55d8b">More...</a><br /></td></tr>
<tr class="separator:aafb0d355ea6891b47940c7bf24a55d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a76d13e1d70ccc9a43c11cda36bcc3414">GetStaticType</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding static type from a given struct info.  <a href="#a76d13e1d70ccc9a43c11cda36bcc3414">More...</a><br /></td></tr>
<tr class="separator:a76d13e1d70ccc9a43c11cda36bcc3414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886a4846aaed5d3cabb7ba6277d895b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a886a4846aaed5d3cabb7ba6277d895b6">StructInfoFromType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a886a4846aaed5d3cabb7ba6277d895b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding struct info from static type.  <a href="#a886a4846aaed5d3cabb7ba6277d895b6">More...</a><br /></td></tr>
<tr class="separator:a886a4846aaed5d3cabb7ba6277d895b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc2189e6a25f2df774b38c7d72f23f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#abfc2189e6a25f2df774b38c7d72f23f9">DeriveCallRetStructInfo</a> (const <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a> &amp;finfo, const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;ctx, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="separator:abfc2189e6a25f2df774b38c7d72f23f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61c04eb7fcb890934bf2a2f221082d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae61c04eb7fcb890934bf2a2f221082d7">EraseToWellDefined</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &amp;var)&gt; f_shape_var_map=nullptr, std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;var)&gt; f_var_map=nullptr, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:ae61c04eb7fcb890934bf2a2f221082d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the info to a corresponding more coarse grained struct info that is still well-defined(with all the vars in scope).  <a href="#ae61c04eb7fcb890934bf2a2f221082d7">More...</a><br /></td></tr>
<tr class="separator:ae61c04eb7fcb890934bf2a2f221082d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7e1abf8c8cb79cd1af9190aa10e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a63a7e1abf8c8cb79cd1af9190aa10e0a">EraseToWellDefined</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;info, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape_var_map, <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; var_map, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a63a7e1abf8c8cb79cd1af9190aa10e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">EraseToWellDefined variant with map.  <a href="#a63a7e1abf8c8cb79cd1af9190aa10e0a">More...</a><br /></td></tr>
<tr class="separator:a63a7e1abf8c8cb79cd1af9190aa10e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be05801cdf62e4e3a012dc2e410302d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1be05801cdf62e4e3a012dc2e410302d">StructInfoBaseCheck</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;base, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;derived, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a1be05801cdf62e4e3a012dc2e410302d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a base check to see if base subsumes derived.  <a href="#a1be05801cdf62e4e3a012dc2e410302d">More...</a><br /></td></tr>
<tr class="separator:a1be05801cdf62e4e3a012dc2e410302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a717c05debf2815aee7bcbe7d61e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad86a717c05debf2815aee7bcbe7d61e4">IsBaseOf</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;base, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;derived, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:ad86a717c05debf2815aee7bcbe7d61e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the relation of two struct info to see if one subsumes another one.  <a href="#ad86a717c05debf2815aee7bcbe7d61e4">More...</a><br /></td></tr>
<tr class="separator:ad86a717c05debf2815aee7bcbe7d61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1c8438730f1ee0320fd8bff9226e0d1b">StructInfoLCA</a> (const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;rhs, <a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *ana=nullptr)</td></tr>
<tr class="memdesc:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unify the two struct info their least common ancestor.  <a href="#a1c8438730f1ee0320fd8bff9226e0d1b">More...</a><br /></td></tr>
<tr class="separator:a1c8438730f1ee0320fd8bff9226e0d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ac9dfb2e19397251bae6ca7f56ba69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a05ac9dfb2e19397251bae6ca7f56ba69">WellFormed</a> (<a class="el" href="classtvm_1_1IRModule.html">IRModule</a> m, bool check_struct_info=true)</td></tr>
<tr class="memdesc:a05ac9dfb2e19397251bae6ca7f56ba69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> is well formed.  <a href="#a05ac9dfb2e19397251bae6ca7f56ba69">More...</a><br /></td></tr>
<tr class="separator:a05ac9dfb2e19397251bae6ca7f56ba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1964d985c44cfab2394ab4c40cc79be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">relay::OpPatternKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af1964d985c44cfab2394ab4c40cc79be">AnalyzeOpPatternKind</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:af1964d985c44cfab2394ab4c40cc79be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> Pattern Kind for PrimFunc, which is used in relax FuseOps.  <a href="#af1964d985c44cfab2394ab4c40cc79be">More...</a><br /></td></tr>
<tr class="separator:af1964d985c44cfab2394ab4c40cc79be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f12c298b63a91b823926ab262575f59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a8f12c298b63a91b823926ab262575f59">ShapeVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a8f12c298b63a91b823926ab262575f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather all shape variables from expression expr.  <a href="#a8f12c298b63a91b823926ab262575f59">More...</a><br /></td></tr>
<tr class="separator:a8f12c298b63a91b823926ab262575f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991f76f84587ac38918659a9b6c16b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a991f76f84587ac38918659a9b6c16b61">BoundVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a991f76f84587ac38918659a9b6c16b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="#a991f76f84587ac38918659a9b6c16b61">More...</a><br /></td></tr>
<tr class="separator:a991f76f84587ac38918659a9b6c16b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa596eb18b15de9ffa9de8271e247e208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa596eb18b15de9ffa9de8271e247e208">FreeVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aa596eb18b15de9ffa9de8271e247e208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="#aa596eb18b15de9ffa9de8271e247e208">More...</a><br /></td></tr>
<tr class="separator:aa596eb18b15de9ffa9de8271e247e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d273a0addea114feac8cde8f982aca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a0d273a0addea114feac8cde8f982aca2">AllVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0d273a0addea114feac8cde8f982aca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="#a0d273a0addea114feac8cde8f982aca2">More...</a><br /></td></tr>
<tr class="separator:a0d273a0addea114feac8cde8f982aca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7a31318967ed6aebd010906c9105e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a92e7a31318967ed6aebd010906c9105e">CalledGlobalVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a92e7a31318967ed6aebd010906c9105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all global variables used in calls in expression expr.  <a href="#a92e7a31318967ed6aebd010906c9105e">More...</a><br /></td></tr>
<tr class="separator:a92e7a31318967ed6aebd010906c9105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47300c3fee5620d66ddf838fece3cfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a47300c3fee5620d66ddf838fece3cfcf">AllGlobalVars</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a47300c3fee5620d66ddf838fece3cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all global variables from expression expr.  <a href="#a47300c3fee5620d66ddf838fece3cfcf">More...</a><br /></td></tr>
<tr class="separator:a47300c3fee5620d66ddf838fece3cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90cb33479533a7f6f657db36e933cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af90cb33479533a7f6f657db36e933cb7">AnalyzeVar2Value</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;m)</td></tr>
<tr class="memdesc:af90cb33479533a7f6f657db36e933cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="#af90cb33479533a7f6f657db36e933cb7">More...</a><br /></td></tr>
<tr class="separator:af90cb33479533a7f6f657db36e933cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4709fb320376b88d0bebd5b599276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a05f4709fb320376b88d0bebd5b599276">AnalyzeVar2Value</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a05f4709fb320376b88d0bebd5b599276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="#a05f4709fb320376b88d0bebd5b599276">More...</a><br /></td></tr>
<tr class="separator:a05f4709fb320376b88d0bebd5b599276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec9430d5a60d65e2f2b48b0e2f7f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a7dec9430d5a60d65e2f2b48b0e2f7f28">AnalyzeVar2Value</a> (const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb)</td></tr>
<tr class="memdesc:a7dec9430d5a60d65e2f2b48b0e2f7f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze var -&gt; value mapping from VarBindings.  <a href="#a7dec9430d5a60d65e2f2b48b0e2f7f28">More...</a><br /></td></tr>
<tr class="separator:a7dec9430d5a60d65e2f2b48b0e2f7f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339a7354e79656228a175a7afa724009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a339a7354e79656228a175a7afa724009">NameToBinding</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;fn)</td></tr>
<tr class="memdesc:a339a7354e79656228a175a7afa724009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mapping from variable name to its Bindings.  <a href="#a339a7354e79656228a175a7afa724009">More...</a><br /></td></tr>
<tr class="separator:a339a7354e79656228a175a7afa724009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641d9a3ee6479bec92fd5878120dac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af641d9a3ee6479bec92fd5878120dac9">DataflowBlockUseDef</a> (const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb)</td></tr>
<tr class="memdesc:af641d9a3ee6479bec92fd5878120dac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the use-def chain of variables inside a dataflow block.  <a href="#af641d9a3ee6479bec92fd5878120dac9">More...</a><br /></td></tr>
<tr class="separator:af641d9a3ee6479bec92fd5878120dac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4e84afbb6276a65142a0afaec6207"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a3cb4e84afbb6276a65142a0afaec6207">FunctionUseDef</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;fn)</td></tr>
<tr class="memdesc:a3cb4e84afbb6276a65142a0afaec6207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the use-def chain of variables inside a function.  <a href="#a3cb4e84afbb6276a65142a0afaec6207">More...</a><br /></td></tr>
<tr class="separator:a3cb4e84afbb6276a65142a0afaec6207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e325600132b49d076de89e71d9834e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a5e325600132b49d076de89e71d9834e0">RemoveAllUnused</a> (const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> fn)</td></tr>
<tr class="memdesc:a5e325600132b49d076de89e71d9834e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unused statements inside DataflowBlocks.  <a href="#a5e325600132b49d076de89e71d9834e0">More...</a><br /></td></tr>
<tr class="separator:a5e325600132b49d076de89e71d9834e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3bcce51ac9c104e7512f7bb9c687f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aea3bcce51ac9c104e7512f7bb9c687f0">MatchExpr</a> (<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt; bindings=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="memdesc:aea3bcce51ac9c104e7512f7bb9c687f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a pattern matches an expression.  <a href="#aea3bcce51ac9c104e7512f7bb9c687f0">More...</a><br /></td></tr>
<tr class="separator:aea3bcce51ac9c104e7512f7bb9c687f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0154b144840b90bb9346840c4fed4513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a0154b144840b90bb9346840c4fed4513">ExtractMatchedExpr</a> (<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> pattern, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt; bindings=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="separator:a0154b144840b90bb9346840c4fed4513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2348a3225e688de5d35d2478344362f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a2348a3225e688de5d35d2478344362f2">MatchGraph</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;ctx, const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; start_hint=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>, bool must_include_hint=false)</td></tr>
<tr class="memdesc:a2348a3225e688de5d35d2478344362f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a sub-graph in a <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> with a graph of patterns and return the mapping.  <a href="#a2348a3225e688de5d35d2478344362f2">More...</a><br /></td></tr>
<tr class="separator:a2348a3225e688de5d35d2478344362f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7390c0faa62d1ef701bb2c45ab5c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aeb7390c0faa62d1ef701bb2c45ab5c57">MatchGraphDefault</a> (const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;dfb, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt; start_hint=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>, bool must_include_hint=false)</td></tr>
<tr class="memdesc:aeb7390c0faa62d1ef701bb2c45ab5c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match a graph-wise pattern with the current context (<a class="el" href="classtvm_1_1relax_1_1PatternContext.html#a074c63b4617244105202f60f8659bd40" title="Get the pass context object on the top of the stack. ">PatternContext::Current()</a>).  <a href="#aeb7390c0faa62d1ef701bb2c45ab5c57">More...</a><br /></td></tr>
<tr class="separator:aeb7390c0faa62d1ef701bb2c45ab5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51bf4cd12992d277cc20eb82881ca23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae51bf4cd12992d277cc20eb82881ca23">UsedBy</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs, int index=-1)</td></tr>
<tr class="memdesc:ae51bf4cd12992d277cc20eb82881ca23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned.  <a href="#ae51bf4cd12992d277cc20eb82881ca23">More...</a><br /></td></tr>
<tr class="separator:ae51bf4cd12992d277cc20eb82881ca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b594f8efba6fb6620a207fc79b46369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1b594f8efba6fb6620a207fc79b46369">operator^</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs)</td></tr>
<tr class="memdesc:a1b594f8efba6fb6620a207fc79b46369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar of UsedBy(lhs, rhs, -1).  <a href="#a1b594f8efba6fb6620a207fc79b46369">More...</a><br /></td></tr>
<tr class="separator:a1b594f8efba6fb6620a207fc79b46369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d3238251393e90f87314ae9ea1d773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae7d3238251393e90f87314ae9ea1d773">OnlyUsedBy</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs, int index=-1)</td></tr>
<tr class="memdesc:ae7d3238251393e90f87314ae9ea1d773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create only-used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned.  <a href="#ae7d3238251393e90f87314ae9ea1d773">More...</a><br /></td></tr>
<tr class="separator:ae7d3238251393e90f87314ae9ea1d773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af2174df5a7b6bfc1e747068c11bcdb3c">operator&gt;&gt;</a> (const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;rhs)</td></tr>
<tr class="memdesc:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar of OnlyUsedBy(lhs, rhs, -1).  <a href="#af2174df5a7b6bfc1e747068c11bcdb3c">More...</a><br /></td></tr>
<tr class="separator:af2174df5a7b6bfc1e747068c11bcdb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af722ba2c513969d2022ba703636a5290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af722ba2c513969d2022ba703636a5290">IsVar</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:af722ba2c513969d2022ba703636a5290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern. ">VarPattern</a> with a name.  <a href="#af722ba2c513969d2022ba703636a5290">More...</a><br /></td></tr>
<tr class="separator:af722ba2c513969d2022ba703636a5290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad2c52b340b0a2524bdcd85d3289a18ac">IsConst</a> ()</td></tr>
<tr class="memdesc:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern. ">ConstantPattern</a>.  <a href="#ad2c52b340b0a2524bdcd85d3289a18ac">More...</a><br /></td></tr>
<tr class="separator:ad2c52b340b0a2524bdcd85d3289a18ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aaa590000b3e0f6bf9e545786c39f4f0f">Wildcard</a> ()</td></tr>
<tr class="memdesc:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html" title="Managed reference to WildcardPatternNode. ">WildcardPattern</a>.  <a href="#aaa590000b3e0f6bf9e545786c39f4f0f">More...</a><br /></td></tr>
<tr class="separator:aaa590000b3e0f6bf9e545786c39f4f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdb4fdc17642caa5813a62a86cb3efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aefdb4fdc17642caa5813a62a86cb3efa">IsExpr</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:aefdb4fdc17642caa5813a62a86cb3efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern. ">ExprPattern</a>.  <a href="#aefdb4fdc17642caa5813a62a86cb3efa">More...</a><br /></td></tr>
<tr class="separator:aefdb4fdc17642caa5813a62a86cb3efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a09cfd9d5bd00311c06b99147d6817f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a2a09cfd9d5bd00311c06b99147d6817f">IsOp</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;op_name)</td></tr>
<tr class="memdesc:a2a09cfd9d5bd00311c06b99147d6817f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern. ">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>.  <a href="#a2a09cfd9d5bd00311c06b99147d6817f">More...</a><br /></td></tr>
<tr class="separator:a2a09cfd9d5bd00311c06b99147d6817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1718ee142e65df8ab080d339566e5c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1718ee142e65df8ab080d339566e5c11">IsCallTIR</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;name, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt; args=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="memdesc:a1718ee142e65df8ab080d339566e5c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_tir (return a tensor)  <a href="#a1718ee142e65df8ab080d339566e5c11">More...</a><br /></td></tr>
<tr class="separator:a1718ee142e65df8ab080d339566e5c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999d07fa03c8175e1268ce8bf99868c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a5999d07fa03c8175e1268ce8bf99868c">IsCallTIR</a> (const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;name, <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> var_args)</td></tr>
<tr class="memdesc:a5999d07fa03c8175e1268ce8bf99868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for call_tir (return a tuple of tensor)  <a href="#a5999d07fa03c8175e1268ce8bf99868c">More...</a><br /></td></tr>
<tr class="separator:a5999d07fa03c8175e1268ce8bf99868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a04d636a53712efdabb9de417af842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa4a04d636a53712efdabb9de417af842">IsTuple</a> (const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &gt; &amp;fields, bool unordered=false)</td></tr>
<tr class="memdesc:aa4a04d636a53712efdabb9de417af842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html" title="Managed reference to TuplePatternNode. ">TuplePattern</a> or <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html" title="Managed reference to UnorderedTuplePatternNode. ">UnorderedTuplePattern</a> (unordered=true)  <a href="#aa4a04d636a53712efdabb9de417af842">More...</a><br /></td></tr>
<tr class="separator:aa4a04d636a53712efdabb9de417af842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af6cb1e75374b6a5d61f9464ffcedd5ee">IsTupleGetItem</a> (const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> tuple, int index=-1)</td></tr>
<tr class="memdesc:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html" title="Managed reference to TupleGetItemPatternNode. ">TupleGetItemPattern</a>.  <a href="#af6cb1e75374b6a5d61f9464ffcedd5ee">More...</a><br /></td></tr>
<tr class="separator:af6cb1e75374b6a5d61f9464ffcedd5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51307c7d89bf22537e026a22a94d109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa51307c7d89bf22537e026a22a94d109">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> call, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; opt_op=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt; opt_args=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt; opt_attrs=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt; opt_sinfo_args=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:aa51307c7d89bf22537e026a22a94d109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>call</code> with the given properties. A null property denotes 'no change'. Returns <code>call</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#aa51307c7d89bf22537e026a22a94d109">More...</a><br /></td></tr>
<tr class="separator:aa51307c7d89bf22537e026a22a94d109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854230e798d25af727b810a9a56d8d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a854230e798d25af727b810a9a56d8d82">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1If.html">If</a> if_expr, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; opt_cond=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; opt_true_branch=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; opt_false_branch=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:a854230e798d25af727b810a9a56d8d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>if_expr</code> with the given properties. A null property denotes 'no change'. Returns <code>if_expr</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#a854230e798d25af727b810a9a56d8d82">More...</a><br /></td></tr>
<tr class="separator:a854230e798d25af727b810a9a56d8d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359f0b3a6e2403f67abebd0da18c962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af359f0b3a6e2403f67abebd0da18c962">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> tuple, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt; opt_fields=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:af359f0b3a6e2403f67abebd0da18c962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>tuple</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#af359f0b3a6e2403f67abebd0da18c962">More...</a><br /></td></tr>
<tr class="separator:af359f0b3a6e2403f67abebd0da18c962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac967aae760d6919718bf1455a6dea81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aac967aae760d6919718bf1455a6dea81">WithFields</a> (<a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a> tuple_get_item, <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; opt_tuple=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; opt_index=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;(), <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt; opt_span=<a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;())</td></tr>
<tr class="memdesc:aac967aae760d6919718bf1455a6dea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>tuple_get_item</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple_get_item</code> if all properties are unchanged. Otherwise, returns a copy with the new fields.  <a href="#aac967aae760d6919718bf1455a6dea81">More...</a><br /></td></tr>
<tr class="separator:aac967aae760d6919718bf1455a6dea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed72bed8b9182caf234b2ddae778c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afed72bed8b9182caf234b2ddae778c39">GetShapeOf</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:afed72bed8b9182caf234b2ddae778c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shape of Expr.  <a href="#afed72bed8b9182caf234b2ddae778c39">More...</a><br /></td></tr>
<tr class="separator:afed72bed8b9182caf234b2ddae778c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8591e3bb5b5ca5ca31964916f27ac1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af8591e3bb5b5ca5ca31964916f27ac1a">PostOrderVisit</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;node, std::function&lt; void(const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;)&gt; fvisit)</td></tr>
<tr class="separator:af8591e3bb5b5ca5ca31964916f27ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba2c5c499d6b632a3cb414e089e3f59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#adba2c5c499d6b632a3cb414e089e3f59">TVM_REGISTER_NODE_TYPE</a> (<a class="el" href="classtvm_1_1relax_1_1PyExprVisitorNode.html">PyExprVisitorNode</a>)</td></tr>
<tr class="separator:adba2c5c499d6b632a3cb414e089e3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7328a18f68ee03915ae0678c5f8bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a74d7328a18f68ee03915ae0678c5f8bd">TVM_REGISTER_NODE_TYPE</a> (<a class="el" href="classtvm_1_1relax_1_1PyExprMutatorNode.html">PyExprMutatorNode</a>)</td></tr>
<tr class="separator:a74d7328a18f68ee03915ae0678c5f8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc02e3f6e603613190eff65a679ea38c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:adc02e3f6e603613190eff65a679ea38c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#adc02e3f6e603613190eff65a679ea38c">ForEachLeaf</a> (const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;msg, FType fvisit)</td></tr>
<tr class="memdesc:adc02e3f6e603613190eff65a679ea38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply fvisit for each leaf elements in the nested message.  <a href="#adc02e3f6e603613190eff65a679ea38c">More...</a><br /></td></tr>
<tr class="separator:adc02e3f6e603613190eff65a679ea38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff256c278f6c4493843a3b8fe5703092"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:aff256c278f6c4493843a3b8fe5703092"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aff256c278f6c4493843a3b8fe5703092">Equal</a> (const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;rhs, FType fequal)</td></tr>
<tr class="memdesc:aff256c278f6c4493843a3b8fe5703092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively compare two nested messages.  <a href="#aff256c278f6c4493843a3b8fe5703092">More...</a><br /></td></tr>
<tr class="separator:aff256c278f6c4493843a3b8fe5703092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411130ea776624757d25953c0afd23e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:a411130ea776624757d25953c0afd23e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a411130ea776624757d25953c0afd23e4">MapToNestedMsg</a> (<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, FType fmapleaf)</td></tr>
<tr class="memdesc:a411130ea776624757d25953c0afd23e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map expr with possible nested-tuple to nested message.  <a href="#a411130ea776624757d25953c0afd23e4">More...</a><br /></td></tr>
<tr class="separator:a411130ea776624757d25953c0afd23e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ac0cb404c219dc00406a5cc62687b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:ad13ac0cb404c219dc00406a5cc62687b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad13ac0cb404c219dc00406a5cc62687b">MapToNestedMsg</a> (<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> sinfo, FType fmapleaf)</td></tr>
<tr class="memdesc:ad13ac0cb404c219dc00406a5cc62687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map structinfo with possible nested-sinfo to nested message.  <a href="#ad13ac0cb404c219dc00406a5cc62687b">More...</a><br /></td></tr>
<tr class="separator:ad13ac0cb404c219dc00406a5cc62687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca8353ff150a403bc950cc945776d51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:acca8353ff150a403bc950cc945776d51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#acca8353ff150a403bc950cc945776d51">MapToNestedMsgBySInfo</a> (<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, FType fmapleaf)</td></tr>
<tr class="memdesc:acca8353ff150a403bc950cc945776d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map expr with possible nested-tuple to nested message.  <a href="#acca8353ff150a403bc950cc945776d51">More...</a><br /></td></tr>
<tr class="separator:acca8353ff150a403bc950cc945776d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad78aea2a337c8133df868081838a81"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:afad78aea2a337c8133df868081838a81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#afad78aea2a337c8133df868081838a81">NestedMsgToExpr</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FType fmapleaf)</td></tr>
<tr class="memdesc:afad78aea2a337c8133df868081838a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map nested message back to the expr.  <a href="#afad78aea2a337c8133df868081838a81">More...</a><br /></td></tr>
<tr class="separator:afad78aea2a337c8133df868081838a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a22d8bde0bbaa62a91f73ff41a4e0a04e">CombineNestedMsg</a> (<a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; lhs, <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; rhs, FType fcombine)</td></tr>
<tr class="memdesc:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively combine two nested message into one.  <a href="#a22d8bde0bbaa62a91f73ff41a4e0a04e">More...</a><br /></td></tr>
<tr class="separator:a22d8bde0bbaa62a91f73ff41a4e0a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename FType &gt; </td></tr>
<tr class="memitem:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae78e913eed24a1c178d68acf66aa9e9c">DecomposeNestedMsg</a> (<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; msg, FType fvisitleaf)</td></tr>
<tr class="memdesc:ae78e913eed24a1c178d68acf66aa9e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively decompose the tuple structure in expr and msg along with it.  <a href="#ae78e913eed24a1c178d68acf66aa9e9c">More...</a><br /></td></tr>
<tr class="separator:ae78e913eed24a1c178d68acf66aa9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3028c04ea455bd0ae3643978fd69d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename FType &gt; </td></tr>
<tr class="memitem:a58d3028c04ea455bd0ae3643978fd69d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a58d3028c04ea455bd0ae3643978fd69d">TransformTupleLeaf</a> (<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt; msgs, FType ftransleaf)</td></tr>
<tr class="memdesc:a58d3028c04ea455bd0ae3643978fd69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively transform the tuple structure in expr and msgs along with it.  <a href="#a58d3028c04ea455bd0ae3643978fd69d">More...</a><br /></td></tr>
<tr class="separator:a58d3028c04ea455bd0ae3643978fd69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cfac860db89f4dd0de3718e4a972d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23cfac860db89f4dd0de3718e4a972d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a23cfac860db89f4dd0de3718e4a972d0">MatchStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a23cfac860db89f4dd0de3718e4a972d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and check if expr have <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> T and return it.  <a href="#a23cfac860db89f4dd0de3718e4a972d0">More...</a><br /></td></tr>
<tr class="separator:a23cfac860db89f4dd0de3718e4a972d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a1cc7fa75a25650e3846c2cde062d96e2">GetStructInfoAs</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a1cc7fa75a25650e3846c2cde062d96e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the structure info of a given expr and try to cast it as const T*.  <a href="#a1cc7fa75a25650e3846c2cde062d96e2">More...</a><br /></td></tr>
<tr class="separator:a1cc7fa75a25650e3846c2cde062d96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80dd203171d2efc5553d3fe8d4e3945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab80dd203171d2efc5553d3fe8d4e3945">GetStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab80dd203171d2efc5553d3fe8d4e3945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying structure info of expr.  <a href="#ab80dd203171d2efc5553d3fe8d4e3945">More...</a><br /></td></tr>
<tr class="separator:ab80dd203171d2efc5553d3fe8d4e3945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">HasVoidStructInfo</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the expr has void struct info.  <a href="#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">More...</a><br /></td></tr>
<tr class="separator:ae0c3fe13cc8a1af27bcb32ddf15bbf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab521e5660159c700a02f430290430592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ab521e5660159c700a02f430290430592">UpdateStructInfo</a> (<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> expr, <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> struct_info)</td></tr>
<tr class="memdesc:ab521e5660159c700a02f430290430592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the struct info of an Expr.  <a href="#ab521e5660159c700a02f430290430592">More...</a><br /></td></tr>
<tr class="separator:ab521e5660159c700a02f430290430592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75236d7c51eb48fbc1859ee89beb02b"><td class="memItemLeft" align="right" valign="top">TVM_ALWAYS_INLINE <a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html">TVMRetValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af75236d7c51eb48fbc1859ee89beb02b">CallPackedWithArgsInArray</a> (const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> f, const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:af75236d7c51eb48fbc1859ee89beb02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to unpack arguments in the array as parameters for the given packed function.  <a href="#af75236d7c51eb48fbc1859ee89beb02b">More...</a><br /></td></tr>
<tr class="separator:af75236d7c51eb48fbc1859ee89beb02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea7bae766b342d5e68696ae89cfdc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#aa7ea7bae766b342d5e68696ae89cfdc5">IsBaseOf</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;base, const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;derived)</td></tr>
<tr class="memdesc:aa7ea7bae766b342d5e68696ae89cfdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the subtype relationship between base and derived.  <a href="#aa7ea7bae766b342d5e68696ae89cfdc5">More...</a><br /></td></tr>
<tr class="separator:aa7ea7bae766b342d5e68696ae89cfdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a8c1def559081fc6abd91dbec581a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#af00a8c1def559081fc6abd91dbec581a">FindLCA</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;t1, const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;t2)</td></tr>
<tr class="memdesc:af00a8c1def559081fc6abd91dbec581a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the lowest common ancestor of two types.  <a href="#af00a8c1def559081fc6abd91dbec581a">More...</a><br /></td></tr>
<tr class="separator:af00a8c1def559081fc6abd91dbec581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac3ba77506e977263f826fed22a593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#adcac3ba77506e977263f826fed22a593">Bind</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; &amp;binds)</td></tr>
<tr class="memdesc:adcac3ba77506e977263f826fed22a593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the variables to a Relax expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> any free variables are introduced into a function, those are added to the function parameters. Additionally this may change the order of parameters if you map a variable to a variable.  <a href="#adcac3ba77506e977263f826fed22a593">More...</a><br /></td></tr>
<tr class="separator:adcac3ba77506e977263f826fed22a593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad237fcb2301b470af00fb8b03d8392d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ad237fcb2301b470af00fb8b03d8392d7">IsBoolScalarType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;ty, bool permit_unknown_rank=true, bool permit_unknown_dtype=true)</td></tr>
<tr class="memdesc:ad237fcb2301b470af00fb8b03d8392d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given type is a boolean scalar type (tensor of rank 0 with a boolean dtype).  <a href="#ad237fcb2301b470af00fb8b03d8392d7">More...</a><br /></td></tr>
<tr class="separator:ad237fcb2301b470af00fb8b03d8392d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#ade67ebcba4b40c0e0c38c0ddd3279131">IsLeafOrTuple</a> (const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given expression is a "leaf" node or tuple node for normalization purposes.  <a href="#ade67ebcba4b40c0e0c38c0ddd3279131">More...</a><br /></td></tr>
<tr class="separator:ade67ebcba4b40c0e0c38c0ddd3279131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fc6bb39c27e25365de9a69b38cd52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relax.html#a38fc6bb39c27e25365de9a69b38cd52e">CopyWithNewParams</a> (<a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> func)</td></tr>
<tr class="memdesc:a38fc6bb39c27e25365de9a69b38cd52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given function. The parameters of the original function would be copied to satisfy the restriction in the well-formed check: any two functions cannot share the same parameter variable.  <a href="#a38fc6bb39c27e25365de9a69b38cd52e">More...</a><br /></td></tr>
<tr class="separator:a38fc6bb39c27e25365de9a69b38cd52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8f6ef3d9aaba0138f730a520d7ebbfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6ef3d9aaba0138f730a520d7ebbfb3">&#9670;&nbsp;</a></span>Expr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">tvm::relax::Expr</a> = typedef <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89e5aa7e722c41dafa36ca83d9d8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89e5aa7e722c41dafa36ca83d9d8091">&#9670;&nbsp;</a></span>ExprNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ae89e5aa7e722c41dafa36ca83d9d8091">tvm::relax::ExprNode</a> = typedef <a class="el" href="classtvm_1_1RelayExprNode.html">RelayExprNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad48f471eb3ea093c316f3a4e9262a418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48f471eb3ea093c316f3a4e9262a418">&#9670;&nbsp;</a></span>FCallPacked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#ad48f471eb3ea093c316f3a4e9262a418">tvm::relax::FCallPacked</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packed function implementation for operators. The relax operator will be lowered to this packed function call during codegen. </p>

</div>
</div>
<a id="a1a2fd4ee22f1a9f4ebd6360992f89e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2fd4ee22f1a9f4ebd6360992f89e15">&#9670;&nbsp;</a></span>FInferStructInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#a1a2fd4ee22f1a9f4ebd6360992f89e15">tvm::relax::FInferStructInfo</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer output struct info given the call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30be57dbb36533467727929c21bd237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30be57dbb36533467727929c21bd237">&#9670;&nbsp;</a></span>StructInfoDeriveFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relax.html#af30be57dbb36533467727929c21bd237">tvm::relax::StructInfoDeriveFunc</a> = typedef <a class="el" href="classtvm_1_1TypedEnvFunc.html">TypedEnvFunc</a>&lt;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>(const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&amp; call, const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a>&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>custom-defined <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> derivation function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived struct info of the call. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a04ee98afc287f8466486f83957bbceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ee98afc287f8466486f83957bbceb2">&#9670;&nbsp;</a></span>BaseCheckResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">tvm::relax::BaseCheckResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fine grained result of base check. </p>
<p>This analysis comes with different levels of checking failures that can help to customize the compilation decisions.</p>
<p>For a given pair of lhs_struct_info, rhs_struct_info. We adopt the following terminology:</p><ul>
<li>LSet = {value | value matches lhs_struct_info}</li>
<li>RSet = {value | value matches rhs_struct_info}</li>
</ul>
<p>See the definition of each level below. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2aea0d6c7bc4e0f3e1ae27af5ab8d3ead1"></a>kFailL0&#160;</td><td class="fielddoc"><p>The two value sets have no intersection at all: Interset(LSet, RSet) = empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a44bf4c796712d49aa9e166a28b5b4877"></a>kFailL1&#160;</td><td class="fielddoc"><p>LSet is not superset of RSet by only looking at static information. </p>
<dl class="section note"><dt>Note</dt><dd>This level will trigger static type checking error when lhs is param and rhs is arg. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a445a5e4200190564cfb0a1a85823831f"></a>kFailL2&#160;</td><td class="fielddoc"><p>WLSet is not superset of RSet because of mismatch in value information. </p>
<p>L1-level mismatches in params of <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode. ">FuncStructInfo</a> is categorized as <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> lhs is <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html" title="Managed reference to FuncStructInfoNode. ">FuncStructInfo</a>, then L1-level mismatch in its params is categorized as L2-level mismatch for lhs.</p>
<p>Design considerations for functions:</p><ul>
<li>(a) We want to be able to erase type/value in function signature when we unify function struct info and preserve simpler representations.</li>
<li>(b) We automatically insert match_cast at function boundary, so we can erase (int)-&gt;int argument as (object)-&gt;int. The input shape/type mismatch will be detected by runtime checks at function boundary. This behavior is also consistent with the PackedFunc behavior.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This level means there is no problem about static known information. It is OK for the checker to do best effort and return this value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a04ee98afc287f8466486f83957bbceb2a42b60afb2c7698ee5c4d41840ca1210e"></a>kPass&#160;</td><td class="fielddoc"><p>LSet is superset of RSet. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a47300c3fee5620d66ddf838fece3cfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47300c3fee5620d66ddf838fece3cfcf">&#9670;&nbsp;</a></span>AllGlobalVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a>&gt; tvm::relax::AllGlobalVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all global variables from expression expr. </p>
<p>AllVars is a superset of BoundVars and FreeVars. The union of BoundVars and FreeVars is Allvars.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all global variables, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a0d273a0addea114feac8cde8f982aca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d273a0addea114feac8cde8f982aca2">&#9670;&nbsp;</a></span>AllVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::AllVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all variables from expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="af1964d985c44cfab2394ab4c40cc79be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1964d985c44cfab2394ab4c40cc79be">&#9670;&nbsp;</a></span>AnalyzeOpPatternKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">relay::OpPatternKind</a> tvm::relax::AnalyzeOpPatternKind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">tir::PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> Pattern Kind for PrimFunc, which is used in relax FuseOps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The PrimFunc to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> Pattern Kind.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This analysis applies on TIR function but is primarily used by relax passes. As a result we place it under the relax namespace. </dd></dl>

</div>
</div>
<a id="af90cb33479533a7f6f657db36e933cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90cb33479533a7f6f657db36e933cb7">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="a05f4709fb320376b88d0bebd5b599276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f4709fb320376b88d0bebd5b599276">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="a7dec9430d5a60d65e2f2b48b0e2f7f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dec9430d5a60d65e2f2b48b0e2f7f28">&#9670;&nbsp;</a></span>AnalyzeVar2Value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&gt; tvm::relax::AnalyzeVar2Value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze var -&gt; value mapping from VarBindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfb</td><td>The dataflow block to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> -&gt; Value (Expr) </dd></dl>

</div>
</div>
<a id="adcac3ba77506e977263f826fed22a593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac3ba77506e977263f826fed22a593">&#9670;&nbsp;</a></span>Bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> tvm::relax::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the variables to a Relax expression. This is a helper function usually called by other pass functions to help optimizations. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> any free variables are introduced into a function, those are added to the function parameters. Additionally this may change the order of parameters if you map a variable to a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">binds</td><td>The variable to expression map that will be used to help the binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated expression. </dd></dl>

</div>
</div>
<a id="a991f76f84587ac38918659a9b6c16b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991f76f84587ac38918659a9b6c16b61">&#9670;&nbsp;</a></span>BoundVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from expression expr. </p>
<p>Bound variables are all variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a92e7a31318967ed6aebd010906c9105e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e7a31318967ed6aebd010906c9105e">&#9670;&nbsp;</a></span>CalledGlobalVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1GlobalVar.html">GlobalVar</a>&gt; tvm::relax::CalledGlobalVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all global variables used in calls in expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all global variables called in expr. </dd></dl>

</div>
</div>
<a id="af75236d7c51eb48fbc1859ee89beb02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75236d7c51eb48fbc1859ee89beb02b">&#9670;&nbsp;</a></span>CallPackedWithArgsInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TVM_ALWAYS_INLINE <a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html">TVMRetValue</a> tvm::relax::CallPackedWithArgsInArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to unpack arguments in the array as parameters for the given packed function. </p>

</div>
</div>
<a id="a92be13bb7d6ad7edd1e82c93b9cae11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be13bb7d6ad7edd1e82c93b9cae11b">&#9670;&nbsp;</a></span>CanProveShapeEqual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::CanProveShapeEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can prove the two symbolic shape arrays equals to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>The analyzer used for integer analysis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prove result.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does best effort prove, which means if result is false, there is still possibility that two shapes equals to each other during runtime. </dd></dl>

</div>
</div>
<a id="aafb0d355ea6891b47940c7bf24a55d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0d355ea6891b47940c7bf24a55d8b">&#9670;&nbsp;</a></span>CanProveShapeEqual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::CanProveShapeEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can prove the two symbolic shape expressions equals to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>The analyzer used for integer analysis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does best effort prove, which means if result is false, there is still possibility that two shapes equals to each other during runtime. </dd></dl>

</div>
</div>
<a id="a22d8bde0bbaa62a91f73ff41a4e0a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d8bde0bbaa62a91f73ff41a4e0a04e">&#9670;&nbsp;</a></span>CombineNestedMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::CombineNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fcombine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively combine two nested message into one. </p>
<p>This function requires the two messages to be compatible with each other. The combination rule is as follows:</p><ul>
<li>combine(null, msg) =&gt; msg</li>
<li>combine(leaf1, leaf2) =&gt; fcombine(leaf1, leaf2)</li>
<li>combine(array1, array2) =&gt; [combine(x, y) for x, y in zip(array1, array2)]</li>
<li>This function will throw an error if array have different size</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">fcombine</td><td>with signature T fcombine(T lhs, T rhs) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>combine function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fc6bb39c27e25365de9a69b38cd52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fc6bb39c27e25365de9a69b38cd52e">&#9670;&nbsp;</a></span>CopyWithNewParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> tvm::relax::CopyWithNewParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given function. The parameters of the original function would be copied to satisfy the restriction in the well-formed check: any two functions cannot share the same parameter variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The relax function to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The copied function. </dd></dl>

</div>
</div>
<a id="af641d9a3ee6479bec92fd5878120dac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641d9a3ee6479bec92fd5878120dac9">&#9670;&nbsp;</a></span>DataflowBlockUseDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt; tvm::relax::DataflowBlockUseDef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the use-def chain of variables inside a dataflow block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfb</td><td>The dataflow block to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map mapping variable definitions to a set of uses. </dd></dl>

</div>
</div>
<a id="ae78e913eed24a1c178d68acf66aa9e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78e913eed24a1c178d68acf66aa9e9c">&#9670;&nbsp;</a></span>DecomposeNestedMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::DecomposeNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fvisitleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively decompose the tuple structure in expr and msg along with it. </p>
<p>This function will call fvisitleaf for each leaf expression in expr. This function will throw an error if the nesting structure in msg does not match the tuple nesting structure in expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression to be decomposed. </td></tr>
    <tr><td class="paramname">fvisitleaf</td><td>with signature fvisitleaf(Expr expr, NestedMsg&lt;T&gt; msg) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The visit function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc2189e6a25f2df774b38c7d72f23f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc2189e6a25f2df774b38c7d72f23f9">&#9670;&nbsp;</a></span>DeriveCallRetStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::DeriveCallRetStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1FuncStructInfo.html">FuncStructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>finfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> &amp;&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1BlockBuilder.html">BlockBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Derive the call's ret value struct info from inputs. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_info</td><td>The function struct info. </td></tr>
    <tr><td class="paramname">call</td><td>The call expression to be derived. </td></tr>
    <tr><td class="paramname">ctx</td><td>The builder context. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derived struct info of the call. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>call-&gt;op field is ignored during derivation and we only rely on information presented by func_sinfo. </dd></dl>

</div>
</div>
<a id="aff256c278f6c4493843a3b8fe5703092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff256c278f6c4493843a3b8fe5703092">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fequal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively compare two nested messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">fequal</td><td>The equal functor with signature bool fequal(T, T) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>the equal comparator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61c04eb7fcb890934bf2a2f221082d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61c04eb7fcb890934bf2a2f221082d7">&#9670;&nbsp;</a></span>EraseToWellDefined() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::EraseToWellDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>f_shape_var_map</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;(const <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>f_var_map</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the info to a corresponding more coarse grained struct info that is still well-defined(with all the vars in scope). </p>
<p>When we are returning a <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> to another scope, it is important to remember that <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> may carry dependencies on var that is not defined the other scope.</p>
<p>In such cases, it is important to call EraseToWellDefined to get another <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> that <b>only</b> contains the vars that are defined in the target scope.</p>
<p>For example, consider the following function</p>
<div class="fragment"><div class="line">@R.function</div><div class="line">def f(x: R.Tensor[(n, m)]):</div><div class="line">    k = tir.Var(<span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;int64&quot;</span>)</div><div class="line">    v0 = opaque_fn(x)</div><div class="line">    v1 = match_cast(v0, R.Tensor[(n, k)])</div><div class="line">    v2 : R.Tensor[(n + 1, k + 2)] = <a class="code" href="namespacetvm_1_1topi.html#a3305d377f96cd20c23032eeada2756d5">pad</a>(v1)</div><div class="line">    return v2</div></div><!-- fragment --><p>In the above code, the return value y have shape <code>(n + 1, k + 2)</code>, However, at the level of function signature, only n, m are defined, k is undefined here.</p>
<p>When we call EraseToWellDefined(R.Tensor[(n + 1, k + 2)], fshape_var_map={n: n, m: m}), we will obtain R.Tensor(ndim=2), which is an erased info that does not depend on k(which is undefined from parameter signature).</p>
<p>However, if we call EraseToWellDefined(R.Tensor[(n + 1, m)], fshape_var_map={n: n, m: m}), Then the return value will be R.Tensor[(n + 1, m)], because both n and m are defined.</p>
<p>We can also make these var map to return a different expression. For example, EraseToWellDefined(R.Tensor[(n + 1, m)], fshape_var_map={n: 2, m: m}) will give us R.Tensor[(3, m)], where n get replaced by 2.</p>
<p>Use this function in the following scenarios:</p><ul>
<li>Decide the struct_info of expr with sub-scopes, such as <a class="el" href="classtvm_1_1relax_1_1If.html">If</a>, <a class="el" href="classtvm_1_1relax_1_1SeqExpr.html">SeqExpr</a></li>
<li>Decide the deduced return struct_info of a function that can be fully decided by params.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
    <tr><td class="paramname">f_shape_var_map</td><td>callback function to specify whether a symbolic shape var is defined and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">f_var_defined</td><td>callback function to specify whether a var is defined in the target scope and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding erased struct info. </dd></dl>

</div>
</div>
<a id="a63a7e1abf8c8cb79cd1af9190aa10e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a7e1abf8c8cb79cd1af9190aa10e0a">&#9670;&nbsp;</a></span>EraseToWellDefined() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::EraseToWellDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape_var_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>var_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EraseToWellDefined variant with map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
    <tr><td class="paramname">f_shape_var_map</td><td>callback function to specify whether a symbolic shape var is defined and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">f_var_defined</td><td>callback function to specify whether a var is defined in the target scope and the value it maps to, return nullopt if var is undefined. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding erased struct info. </dd></dl>

</div>
</div>
<a id="a0154b144840b90bb9346840c4fed4513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0154b144840b90bb9346840c4fed4513">&#9670;&nbsp;</a></span>ExtractMatchedExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&gt; &gt; tvm::relax::ExtractMatchedExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>bindings</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af00a8c1def559081fc6abd91dbec581a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a8c1def559081fc6abd91dbec581a">&#9670;&nbsp;</a></span>FindLCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Type.html">Type</a> tvm::relax::FindLCA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the lowest common ancestor of two types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> 1. </td></tr>
    <tr><td class="paramname">u</td><td><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest common ancestor of two types. </dd></dl>

</div>
</div>
<a id="adc02e3f6e603613190eff65a679ea38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc02e3f6e603613190eff65a679ea38c">&#9670;&nbsp;</a></span>ForEachLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::ForEachLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply fvisit for each leaf elements in the nested message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fvisit</td><td>The visit callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>the visitor type with signature void fvisit(T) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa596eb18b15de9ffa9de8271e247e208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa596eb18b15de9ffa9de8271e247e208">&#9670;&nbsp;</a></span>FreeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::FreeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free type parameters from expression expr. </p>
<p>Free variables are variables that are not bound by a varbinding or a function parameter in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a id="a3cb4e84afbb6276a65142a0afaec6207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb4e84afbb6276a65142a0afaec6207">&#9670;&nbsp;</a></span>FunctionUseDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt;, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; &gt; tvm::relax::FunctionUseDef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the use-def chain of variables inside a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from variable definitions to a set of uses and variables needed by return value. </dd></dl>

</div>
</div>
<a id="afed72bed8b9182caf234b2ddae778c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed72bed8b9182caf234b2ddae778c39">&#9670;&nbsp;</a></span>GetShapeOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> tvm::relax::GetShapeOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the shape of Expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresonding shape.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function requires expr to be normalized. The function will report an error if expr's <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> is not <a class="el" href="classtvm_1_1relax_1_1TensorStructInfo.html" title="Managed reference to TensorStructInfoNode. ">TensorStructInfo</a>. It will try to return symbolic function when possible. <a class="el" href="classtvm_1_1relax_1_1If.html">If</a> the tensor do not have a compile-time symbolic shape, the function will then choose to return <a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>(relax.op.shape_of, [expr]). </dd></dl>

</div>
</div>
<a id="a76d13e1d70ccc9a43c11cda36bcc3414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d13e1d70ccc9a43c11cda36bcc3414">&#9670;&nbsp;</a></span>GetStaticType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Type.html">Type</a> tvm::relax::GetStaticType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the corresponding static type from a given struct info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The struct info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding static type. </dd></dl>

</div>
</div>
<a id="ab80dd203171d2efc5553d3fe8d4e3945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80dd203171d2efc5553d3fe8d4e3945">&#9670;&nbsp;</a></span>GetStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::GetStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying structure info of expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>underlying struct info. </dd></dl>

</div>
</div>
<a id="a1cc7fa75a25650e3846c2cde062d96e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc7fa75a25650e3846c2cde062d96e2">&#9670;&nbsp;</a></span>GetStructInfoAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* tvm::relax::GetStructInfoAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the structure info of a given expr and try to cast it as const T*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer. Returns nullptr if the type does not match </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying structure info type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0c3fe13cc8a1af27bcb32ddf15bbf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c3fe13cc8a1af27bcb32ddf15bbf1c">&#9670;&nbsp;</a></span>HasVoidStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::HasVoidStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the expr has void struct info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the expr has void struct info. </dd></dl>

</div>
</div>
<a id="aa7ea7bae766b342d5e68696ae89cfdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ea7bae766b342d5e68696ae89cfdc5">&#9670;&nbsp;</a></span>IsBaseOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsBaseOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the subtype relationship between base and derived. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base type. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> <code>derived</code> is a subtype of <code>base</code> or if both are the same type, returns true. Otherwise returns false. </dd></dl>

</div>
</div>
<a id="ad86a717c05debf2815aee7bcbe7d61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86a717c05debf2815aee7bcbe7d61e4">&#9670;&nbsp;</a></span>IsBaseOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsBaseOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the relation of two struct info to see if one subsumes another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base struct info. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived struct info. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the relation holds. </dd></dl>

</div>
</div>
<a id="ad237fcb2301b470af00fb8b03d8392d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad237fcb2301b470af00fb8b03d8392d7">&#9670;&nbsp;</a></span>IsBoolScalarType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsBoolScalarType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_unknown_rank</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_unknown_dtype</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given type is a boolean scalar type (tensor of rank 0 with a boolean dtype). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>The input type. </td></tr>
    <tr><td class="paramname">permit_unknown_rank</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, it will permit the input type to have unknown rank (ndim of -1), which will require a dynamic check. </td></tr>
    <tr><td class="paramname">permit_unknown_dtype</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> true, it will permit the input type to have an unknown dtype (namely, void), which will require a dynamic check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the input type is a boolean scalar type (or, depending on options, has unknown rank or dtype) </dd></dl>

</div>
</div>
<a id="a1718ee142e65df8ab080d339566e5c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1718ee142e65df8ab080d339566e5c11">&#9670;&nbsp;</a></span>IsCallTIR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallTIR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_tir (return a tensor) </p>

</div>
</div>
<a id="a5999d07fa03c8175e1268ce8bf99868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5999d07fa03c8175e1268ce8bf99868c">&#9670;&nbsp;</a></span>IsCallTIR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1CallPattern.html">CallPattern</a> tvm::relax::IsCallTIR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1TuplePattern.html">TuplePattern</a>&#160;</td>
          <td class="paramname"><em>var_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for call_tir (return a tuple of tensor) </p>

</div>
</div>
<a id="ad2c52b340b0a2524bdcd85d3289a18ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c52b340b0a2524bdcd85d3289a18ac">&#9670;&nbsp;</a></span>IsConst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html">ConstantPattern</a> tvm::relax::IsConst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ConstantPattern.html" title="Managed reference to a ConstantPattern. ">ConstantPattern</a>. </p>

</div>
</div>
<a id="aefdb4fdc17642caa5813a62a86cb3efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdb4fdc17642caa5813a62a86cb3efa">&#9670;&nbsp;</a></span>IsExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a> tvm::relax::IsExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern. ">ExprPattern</a>. </p>

</div>
</div>
<a id="ade67ebcba4b40c0e0c38c0ddd3279131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade67ebcba4b40c0e0c38c0ddd3279131">&#9670;&nbsp;</a></span>IsLeafOrTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::IsLeafOrTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given expression is a "leaf" node or tuple node for normalization purposes. </p>
<p>The following expressions are defined as leaf nodes: <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1relax_1_1Constant.html">Constant</a>, <a class="el" href="classtvm_1_1relax_1_1ShapeExpr.html">ShapeExpr</a>, <a class="el" href="classtvm_1_1GlobalVar.html" title="Managed reference to GlobalVarNode. ">GlobalVar</a>, <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>, <a class="el" href="classtvm_1_1relax_1_1ExternFunc.html">ExternFunc</a>.</p>
<p>Tuples are included in this list mainly for convenience in grouping operator arguments. <em>Note</em>: Since tuples can contain nested expressions, it is necessary to ensure that values nested inside them are also leaves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the input expression is a "leaf" node (a value allowed to appear inline without being bound to a var during normalization). </dd></dl>

</div>
</div>
<a id="a2a09cfd9d5bd00311c06b99147d6817f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a09cfd9d5bd00311c06b99147d6817f">&#9670;&nbsp;</a></span>IsOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1ExprPattern.html">ExprPattern</a> tvm::relax::IsOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1ExprPattern.html" title="Managed reference to an ExprPattern. ">ExprPattern</a> base on an <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>. </p>

</div>
</div>
<a id="aa4a04d636a53712efdabb9de417af842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a04d636a53712efdabb9de417af842">&#9670;&nbsp;</a></span>IsTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> tvm::relax::IsTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unordered</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating <a class="el" href="classtvm_1_1relax_1_1TuplePattern.html" title="Managed reference to TuplePatternNode. ">TuplePattern</a> or <a class="el" href="classtvm_1_1relax_1_1UnorderedTuplePattern.html" title="Managed reference to UnorderedTuplePatternNode. ">UnorderedTuplePattern</a> (unordered=true) </p>

</div>
</div>
<a id="af6cb1e75374b6a5d61f9464ffcedd5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cb1e75374b6a5d61f9464ffcedd5ee">&#9670;&nbsp;</a></span>IsTupleGetItem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html">TupleGetItemPattern</a> tvm::relax::IsTupleGetItem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1TupleGetItemPattern.html" title="Managed reference to TupleGetItemPatternNode. ">TupleGetItemPattern</a>. </p>

</div>
</div>
<a id="af722ba2c513969d2022ba703636a5290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af722ba2c513969d2022ba703636a5290">&#9670;&nbsp;</a></span>IsVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1VarPattern.html">VarPattern</a> tvm::relax::IsVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1VarPattern.html" title="Managed reference to a VarPattern. ">VarPattern</a> with a name. </p>

</div>
</div>
<a id="a411130ea776624757d25953c0afd23e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411130ea776624757d25953c0afd23e4">&#9670;&nbsp;</a></span>MapToNestedMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map expr with possible nested-tuple to nested message. </p>
<p>This function will unpack recursive tuples and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the tuple structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>&lt;T&gt; fmap(Expr)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13ac0cb404c219dc00406a5cc62687b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13ac0cb404c219dc00406a5cc62687b">&#9670;&nbsp;</a></span>MapToNestedMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td>
          <td class="paramname"><em>sinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map structinfo with possible nested-sinfo to nested message. </p>
<p>This function will unpack recursive sinfo and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the tuple structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinfo</td><td>The input struct info. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>&lt;T&gt; fmap(StructInfo)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca8353ff150a403bc950cc945776d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca8353ff150a403bc950cc945776d51">&#9670;&nbsp;</a></span>MapToNestedMsgBySInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt;T&gt; tvm::relax::MapToNestedMsgBySInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map expr with possible nested-tuple to nested message. </p>
<p>This function will unpack recursive expr by its struct info and run fmapleaf for each leaf, then recursively combines the results together into a <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>.</p>
<p>The nesting structure will corresponds to the struct info of expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression which should have struct info. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html" title="Container that stores possibly nested message with leaf message type T. ">NestedMsg</a>&lt;T&gt; fmapleaf(Expr)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea3bcce51ac9c104e7512f7bb9c687f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3bcce51ac9c104e7512f7bb9c687f0">&#9670;&nbsp;</a></span>MatchExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::MatchExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Map.html">runtime::Map</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>bindings</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a pattern matches an expression. </p>
<dl class="section note"><dt>Note</dt><dd>The behavior of MatchExpr is to match a <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">relax.Expr</a> (<code>expr</code>) syntactically through one given pattern (<code>pattern</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to match </td></tr>
    <tr><td class="paramname">expr</td><td>The expression to match </td></tr>
    <tr><td class="paramname">bindings</td><td>The mapping from <a class="el" href="classtvm_1_1relax_1_1Var.html">relax.Var</a> to <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">relax.Expr</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if matched </dd>
<dd>
false if unmatched </dd></dl>

</div>
</div>
<a id="a2348a3225e688de5d35d2478344362f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2348a3225e688de5d35d2478344362f2">&#9670;&nbsp;</a></span>MatchGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::runtime::Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::MatchGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternContext.html">PatternContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"><em>start_hint</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>must_include_hint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match a sub-graph in a <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> with a graph of patterns and return the mapping. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm returns the first matched sub-graph. Use <code>start_hint</code> to specify the starting point of the matching so that we can distinguish multiple matches.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The graph-wise patterns. </td></tr>
    <tr><td class="paramname">dfb</td><td>The function to match. </td></tr>
    <tr><td class="paramname">start_hint</td><td>The starting point expression to match to distinguish multiple matches. </td></tr>
    <tr><td class="paramname">must_include_hint</td><td><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> start_hint is given, the return pattern must include start_hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tvm::runtime::Map&lt;DFPattern, Var&gt; </dd></dl>

</div>
</div>
<a id="aeb7390c0faa62d1ef701bb2c45ab5c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7390c0faa62d1ef701bb2c45ab5c57">&#9670;&nbsp;</a></span>MatchGraphDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">tvm::runtime::Map</a>&lt;<a class="el" href="classtvm_1_1relax_1_1DFPattern.html">DFPattern</a>, <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a>&gt; tvm::relax::MatchGraphDefault </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>dfb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1relax_1_1Var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"><em>start_hint</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>must_include_hint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match a graph-wise pattern with the current context (<a class="el" href="classtvm_1_1relax_1_1PatternContext.html#a074c63b4617244105202f60f8659bd40" title="Get the pass context object on the top of the stack. ">PatternContext::Current()</a>). </p>

</div>
</div>
<a id="a23cfac860db89f4dd0de3718e4a972d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cfac860db89f4dd0de3718e4a972d0">&#9670;&nbsp;</a></span>MatchStructInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;T&gt; tvm::relax::MatchStructInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match and check if expr have <a class="el" href="classtvm_1_1relax_1_1StructInfo.html" title="Managed reference to StructInfoNode. ">StructInfo</a> T and return it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of match. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying structure info type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339a7354e79656228a175a7afa724009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339a7354e79656228a175a7afa724009">&#9670;&nbsp;</a></span>NameToBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Map.html">Map</a>&lt;<a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relax_1_1Binding.html">Binding</a>&gt; &gt; tvm::relax::NameToBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mapping from variable name to its Bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to be analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mapping from variable name to its Bindings. </dd></dl>

</div>
</div>
<a id="afad78aea2a337c8133df868081838a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad78aea2a337c8133df868081838a81">&#9670;&nbsp;</a></span>NestedMsgToExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> tvm::relax::NestedMsgToExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>fmapleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map nested message back to the expr. </p>
<p>This function will decompose the nested message and run fmapleaf for each leaf message and get the leaf expr, then recursively combines the results as tuple expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The input nested message. </td></tr>
    <tr><td class="paramname">fmapleaf</td><td>The mapping function for each leaf with signature <code>Expr fmapleaf(Optional&lt;T&gt;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg. </td></tr>
    <tr><td class="paramname">FType</td><td>The mapping function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7d3238251393e90f87314ae9ea1d773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d3238251393e90f87314ae9ea1d773">&#9670;&nbsp;</a></span>OnlyUsedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::OnlyUsedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create only-used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">index</td><td>lhs[-1] is used as the index'th argument of rhs[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html" title="Managed reference to pattern sequences. ">PatternSeq</a> The concatenated sequence of [*lhs, *rhs]. </dd></dl>

</div>
</div>
<a id="af2174df5a7b6bfc1e747068c11bcdb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2174df5a7b6bfc1e747068c11bcdb3c">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntax sugar of OnlyUsedBy(lhs, rhs, -1). </p>

</div>
</div>
<a id="a1b594f8efba6fb6620a207fc79b46369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b594f8efba6fb6620a207fc79b46369">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntax sugar of UsedBy(lhs, rhs, -1). </p>

</div>
</div>
<a id="af8591e3bb5b5ca5ca31964916f27ac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8591e3bb5b5ca5ca31964916f27ac1a">&#9670;&nbsp;</a></span>PostOrderVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e325600132b49d076de89e71d9834e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e325600132b49d076de89e71d9834e0">&#9670;&nbsp;</a></span>RemoveAllUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a> tvm::relax::RemoveAllUnused </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1Function.html">Function</a>&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unused statements inside DataflowBlocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to remove unused statements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function that contains no unused statements in <a class="el" href="classtvm_1_1relax_1_1DataflowBlock.html">DataflowBlock</a>. </dd></dl>

</div>
</div>
<a id="a8f12c298b63a91b823926ab262575f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f12c298b63a91b823926ab262575f59">&#9670;&nbsp;</a></span>ShapeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">tir::Var</a>&gt; tvm::relax::ShapeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather all shape variables from expression expr. </p>
<p>This analysis is intended to be called on shape expressions (those set as the shape_ of another expression).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. Meant to be a shape expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of shape variables (<a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">tir::Var</a>) </dd></dl>

</div>
</div>
<a id="a1be05801cdf62e4e3a012dc2e410302d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be05801cdf62e4e3a012dc2e410302d">&#9670;&nbsp;</a></span>StructInfoBaseCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2">BaseCheckResult</a> tvm::relax::StructInfoBaseCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a base check to see if base subsumes derived. </p>
<p>This function returns fine-grained base-check result on reasons of failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base struct info. </td></tr>
    <tr><td class="paramname">derived</td><td>The derived struct info. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the relation holds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacetvm_1_1relax.html#a04ee98afc287f8466486f83957bbceb2" title="Fine grained result of base check. ">BaseCheckResult</a> </dd></dl>

</div>
</div>
<a id="a886a4846aaed5d3cabb7ba6277d895b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886a4846aaed5d3cabb7ba6277d895b6">&#9670;&nbsp;</a></span>StructInfoFromType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::StructInfoFromType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the corresponding struct info from static type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding struct info. </dd></dl>

</div>
</div>
<a id="a1c8438730f1ee0320fd8bff9226e0d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8438730f1ee0320fd8bff9226e0d1b">&#9670;&nbsp;</a></span>StructInfoLCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> tvm::relax::StructInfoLCA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1arith_1_1Analyzer.html">arith::Analyzer</a> *&#160;</td>
          <td class="paramname"><em>ana</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unify the two struct info their least common ancestor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
    <tr><td class="paramname">ana</td><td>Optional context analyzer to prove symbolic expression equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unified information. </dd></dl>

</div>
</div>
<a id="a58d3028c04ea455bd0ae3643978fd69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d3028c04ea455bd0ae3643978fd69d">&#9670;&nbsp;</a></span>TransformTupleLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename FType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> tvm::relax::TransformTupleLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; <a class="el" href="classtvm_1_1relax_1_1NestedMsg.html">NestedMsg</a>&lt; T &gt;, N &gt;&#160;</td>
          <td class="paramname"><em>msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FType&#160;</td>
          <td class="paramname"><em>ftransleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively transform the tuple structure in expr and msgs along with it. </p>
<p>This function will call ftransleaf for each leaf expression in expr. This function will throw an error if the nesting structure in msg does not match the tuple nesting structure in expr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression to be transform.  </td></tr>
    <tr><td class="paramname">msgs</td><td>The input messages to guide the transformation. </td></tr>
    <tr><td class="paramname">ftransleaf</td><td>with signature ftransleaf(Expr, Array&lt;NestedMsg&lt;T&gt;&gt;)-&gt;Expr </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the content type of nested msg </td></tr>
    <tr><td class="paramname">N</td><td>the number of messages </td></tr>
    <tr><td class="paramname">FType</td><td>The visit function type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adba2c5c499d6b632a3cb414e089e3f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba2c5c499d6b632a3cb414e089e3f59">&#9670;&nbsp;</a></span>TVM_REGISTER_NODE_TYPE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relax::TVM_REGISTER_NODE_TYPE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1PyExprVisitorNode.html">PyExprVisitorNode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74d7328a18f68ee03915ae0678c5f8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d7328a18f68ee03915ae0678c5f8bd">&#9670;&nbsp;</a></span>TVM_REGISTER_NODE_TYPE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::relax::TVM_REGISTER_NODE_TYPE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1PyExprMutatorNode.html">PyExprMutatorNode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab521e5660159c700a02f430290430592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab521e5660159c700a02f430290430592">&#9670;&nbsp;</a></span>UpdateStructInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relax::UpdateStructInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;</td>
          <td class="paramname"><em>struct_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the struct info of an Expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The Expr whose struct info to be updated. </td></tr>
    <tr><td class="paramname">shape</td><td>The struct_info assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We ensure idempotence, that is we can only update the struct_info of an Expr only if the original one is nullptr. </dd></dl>

</div>
</div>
<a id="ae51bf4cd12992d277cc20eb82881ca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51bf4cd12992d277cc20eb82881ca23">&#9670;&nbsp;</a></span>UsedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> tvm::relax::UsedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relax_1_1PatternSeq.html">PatternSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create used-by relationship between lhs[-1] and rhs[0], with [*lhs, *rhs] returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side of the used-by relationship. </td></tr>
    <tr><td class="paramname">index</td><td>lhs[-1] is used as the index'th argument of rhs[0]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1relax_1_1PatternSeq.html" title="Managed reference to pattern sequences. ">PatternSeq</a> The concatenated sequence of [*lhs, *rhs]. </dd></dl>

</div>
</div>
<a id="a05ac9dfb2e19397251bae6ca7f56ba69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ac9dfb2e19397251bae6ca7f56ba69">&#9670;&nbsp;</a></span>WellFormed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relax::WellFormed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_struct_info</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> is well formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> to check. </td></tr>
    <tr><td class="paramname">check_struct_info</td><td>A boolean flag indicating if the property "every Expr
must have defined structure info" will be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a> is well formed, false if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>By default the structure info is always checked. It is only in test cases where <code>check_struct_info</code> might be false, so that other well-formed requirements will be well tested and will not be blocked by not having structure info. </dd></dl>

</div>
</div>
<a id="aaa590000b3e0f6bf9e545786c39f4f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa590000b3e0f6bf9e545786c39f4f0f">&#9670;&nbsp;</a></span>Wildcard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html">WildcardPattern</a> tvm::relax::Wildcard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntatic Sugar for creating a <a class="el" href="classtvm_1_1relax_1_1WildcardPattern.html" title="Managed reference to WildcardPatternNode. ">WildcardPattern</a>. </p>

</div>
</div>
<a id="aa51307c7d89bf22537e026a22a94d109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51307c7d89bf22537e026a22a94d109">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Call.html">Call</a>&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_op</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_args</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_attrs</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_sinfo_args</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="classtvm_1_1relax_1_1StructInfo.html">StructInfo</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>call</code> with the given properties. A null property denotes 'no change'. Returns <code>call</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="a854230e798d25af727b810a9a56d8d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854230e798d25af727b810a9a56d8d82">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1If.html">If</a>&#160;</td>
          <td class="paramname"><em>if_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_cond</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_true_branch</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_false_branch</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>if_expr</code> with the given properties. A null property denotes 'no change'. Returns <code>if_expr</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="af359f0b3a6e2403f67abebd0da18c962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359f0b3a6e2403f67abebd0da18c962">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1Tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>opt_fields</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1runtime_1_1Array.html">Array</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>tuple</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
<a id="aac967aae760d6919718bf1455a6dea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac967aae760d6919718bf1455a6dea81">&#9670;&nbsp;</a></span>WithFields() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a> tvm::relax::WithFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1relax_1_1TupleGetItem.html">TupleGetItem</a>&#160;</td>
          <td class="paramname"><em>tuple_get_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_tuple</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="namespacetvm_1_1relax.html#a8f6ef3d9aaba0138f730a520d7ebbfb3">Expr</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_index</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Integer.html">Integer</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt; <a class="el" href="classtvm_1_1Span.html">Span</a> &gt;&#160;</td>
          <td class="paramname"><em>opt_span</em> = <code><a class="el" href="classtvm_1_1runtime_1_1Optional.html">Optional</a>&lt;&#160;<a class="el" href="classtvm_1_1Span.html">Span</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>tuple_get_item</code> with the given properties. A null property denotes 'no change'. Returns <code>tuple_get_item</code> if all properties are unchanged. Otherwise, returns a copy with the new fields. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
